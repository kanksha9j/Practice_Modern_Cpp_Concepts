Class: It is a user defined data type that holds its own data members and functions that can be accesssed and used by creating an instance of the class.

Enum class: Enum classes provide stronger type safety than traditional enums. In traditional enum, two enums cannot share same names, also no variable can have same name as that which is in some enum.

This pointer: It is an implicit(hidden) pointer that is automatically created to point to all non-static member functions or variables. It points to the current object that calls the function. In class A, it has type A* and (A* const) for const functions. *this will return the current object. Used to resolve name conflicts.

OOPs Concepts:
Abstraction in C++: It is the process of hiding implementation details or features from the user. It focuses on what the object does rather than how it does. It is achieved by using abstract classes.
Abstract class: A classe that has atleast one pure virtual function. The class cannot be instantiated.
A pure virtual function in C++ is a virtual function that has no implementation in the base class and must be overridden by derived classes.

RAII: Resource Acquisition is initialization. 
It is a C++ programming technique that binds a lifecycle of resource (like memory,file handles, locks,socket) to the lifetime of an object.
Means when object is constructed it aquires a resource and when object is destroyed the resource is released. This automatic cleanup of resource is done through destructors, which makes resource management safer and less error prone.

A shallow copy copies the pointer, not the data it points to, which means two objects end up sharing the same resource. This can cause double-delete and undefined behavior.
A deep copy allocates new memory and duplicates the underlying data, so each object owns its own resource safely.
When a class manages resources manually, we must implement a deep copy using custom copy constructor and copy assignment, which leads to the Rule of 3. With move semantics in C++11, this extends to the Rule of 5.

Move semantics enable the transfer of resources and ownership of objects, inside and outside containers, and across threads
while ensuring resource safety.

std::move: transfers the ownership from one object to another. After this the original pointer no longer owns the object.

unique ptr: 
It is defined in header <memory>. It is a smart pointer that owns and manages object via a pointer and disposes the object when the unique_ptr goes out of scope. 
When a unique_ptr goes out of scope, its destructor calls delete on the owned pointer automatically. 

shared pointer:
It is a smart pointer that retains shared ownership of an object through a pointer. Several shared pointers can own and manage the same object. It maintains a reference count that increments when a new shared pointer points to the same object. When the reference count is equal to 0 , the object is destroyed and memory is deallocated. Destruction order is determined by reference count reaching 0. The last shared_ptr holding the object controls when it’s deleted.

Reference count:
The number of shared_ptrs owning the object. The reference count belongs to the object being managed,
not to any individual std::shared_ptr. 

Circular reference:
Reference cycling happens when two or more objects managed by shared pointer own each other meaning each hold shared pointer to other. So this prevents the objects from getting deleted as the reference count never reaches 0 and thus causes memory leak.

weak ptr: 
Weak ptr is a smart pointer that has a non-owning(weak ) reference to an object that is managed by shared pointer. It must be converted to sharerd pointer to access the referenced object. means in short it observes a shared ptr with weak reference. Weak pointer models temporary ownership.
Weak pointer is used to break the reference cycles formed by objects managedby shared pointer. In such cases shared pointer count cannot reach 0 and memory is leaked. To prevent this one of the pointers in the cycle is made weak.

A lambda function in C++ is an anonymous function (a function without a name) that you can define directly in an expression.
It is used to create short, inline callable objects.
A lambda function in C++ is an anonymous function created using a lambda expression, which may capture variables from its surrounding scope and acts as a callable object.

Move Semantics: Move semantics: copies the object from source to target using shallow copy and then deletes the dynamic resources of source object.
copy constructor: if there are temporary values. assigns new memory , copies and then destroys temporary. it is costly. so use move.

Rule of 3 is the old version (pre-C++11): If a class manually manages a resource (e.g., via new/delete or raw handles) and you need to define a custom destructor, copy constructor, or copy assignment operator, then you must define all three.
Because: A raw pointer requires custom deep copy, Destructor must delete/free the resource, Copy assignment must avoid double-delete.

Rule of 5 is the modern version (C++11 and later) : If you manually manage a resource and define any one of the special member functions (destructor, copy/move constructors, copy/move assignment), you should define all five to ensure correct and safe resource management. 

Rule of Zero is the preferred design approach today : Modern C++ actually prefers that you don’t implement any of these manually.
If you use RAII classes like: std::vector, std::string, std::unique_ptr, std::shared_ptr, Then the compiler-generated versions are safe and you follow:
“Classes should not manually manage resources. Prefer RAII wrappers so you need zero special members.”

this pointer: In C++, 'this' pointer is an implicit pointer available inside all non-static member function, and it always points to the current object that called the function. This pointer is internally used by methods to access the other members.

noexcept: When you write noexcept, it tells the compiler that the function will not throw an exception. When the compiler has this knowledge it will make certain optimizations. Many STL operations like vector, behave differently with noexcept move constructor and prefer them for safe re-allocation and without fallback to copying. If the function does throw an exception at runtime, then std::terminate is called and the application will stop immediately.

Why use Move constructor? Allows transfer of resources from one object to another instead of copying them. It prevents expensive deep copies eg. large heap allocation,arrays or buffers, as copying requires duplicating of all these resources which is also slow. STL containers rely heavily on move and allows faster re-allocation of resources with move.

C++17:
-

std::variant :
-
It is a type safe union. It can hold exactly one value out of several possible types.
eg: std::variant<int, float, std::string> v; // At any time v contains either an int/float/string.
std::variant is in <variant>
- Provides:
std::get
std::get_if
std::holds_alternative
index()
std::visit
- Throws std::bad_variant_access if you call std::get with the wrong type.

string_view: string_view: std::string_view is a lightweight, non-owning reference to a string introduced in C++17.
It provides a read-only view of a character sequence without copying or allocating memory.
Internally, it simply stores:
1. a pointer to the first character
2. the length of the string

Because it does not own the data, it is very efficient for passing substrings or string parameters, but it becomes invalid if the underlying string it refers to is destroyed.
if str1 is out of scope or deleted, and str2 is used , it is actually a dangling reference. Therefore, a std::string_view must not refer to data stored in a local variable that will be destroyed, such as a std::string inside a function returning the view.




